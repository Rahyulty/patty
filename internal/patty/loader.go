package patty

import (
	"fmt"
	"os"
)

const LoaderPath = "patty_loader.lua"

func writeLoaderFile() error {
	// this loader assumes lua rocks tree layout:
	// .patth/share/lua/{the version of lua}..
	// .patty/lib/lua/{the version}/..

	//  it finds the lua version at runtime from the _VERSION global

	content := `-- Generated by Patty. Safe to commit (small), but typically regnerated.
local v = _VERSION or "Lua 5.1"
local majmin = v:match("(%d+%.%d+)") or "5.1"

local function prepend_path(current, addition)
    -- if the addition is already in the current path, return the current path
    if current:find(addition, 1, true) then return current end
    return addition .. ";" .. current
end

local share = "./.patty/share/lua/" .. majmin
local lib = "./.patty/lib/lua/" .. majmin

package.path = prepend_path(package.path, share .. "/?.lua")
package.path = prepend_path(package.path, share .. "/?/init.lua")

-- honestly im trying common native module suffixes acrross the platforms so this may not work on all platforms
-- im gonna try and find a way so that we dont even need a patty loader at all but for now this is a good start
package.cpath = prepend_path(package.cpath, lib .. "/?.so")
package.cpath = prepend_path(package.cpath, lib .. "/?.dll")
package.cpath = prepend_path(package.cpath, lib .. "/?.dylib")
`

	file, err := os.Create(LoaderPath)
	if err != nil {
		return fmt.Errorf("failed to create loader file: %w", err)
	}
	defer file.Close()

	_, err = file.WriteString(content)
	if err != nil {
		return fmt.Errorf("failed to write loader file: %w", err)
	}

	return nil
}

func EnsurePattyDir() error {
	return os.MkdirAll(".patty", 0o755)
}

func PrintPostInstallHint() {
	fmt.Println("\nPatty installed deps into .patty/")
	fmt.Println("In your Lua entrypoint, add:")
	fmt.Println(` require("patty_loader")`)
}
